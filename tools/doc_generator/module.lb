#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Copyright (c) 2017-2018, Fabian Greif
# Copyright (c) 2017-2018, Niklas Hauser
#
# This file is part of the modm project.
#
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.
# -----------------------------------------------------------------------------

import os
import re
import sys
import json
import fnmatch
import traceback
import subprocess
import graphviz as gv

from lxml import etree
from pathlib import Path
from collections import defaultdict, OrderedDict

def cleanHtml(docstr):
    descr = docstr.decode("utf-8")
    descr = re.sub(r"<programlisting>", "\n\n```cpp\n", descr)
    descr = re.sub(r"</programlisting>", "\n```\n\n", descr)
    descr = re.sub(r"</?computeroutput>", "`", descr)
    descr = re.sub(r"<parametername>", "1. `", descr)
    descr = re.sub(r"</parametername>", "`", descr)
    descr = re.sub(r"<parameterdescription>\n", "  ", descr)
    descr = re.sub(r"<(/?para|sp/)>", " ", descr)
    descr = re.sub(r"(<simplesect>.*?</simplesect>|<.*?>)", "", descr)
    descr = re.sub(r"&lt;", "<", descr)
    descr = re.sub(r"&gt;", ">", descr)
    return descr.strip(" ")

def getText(obj, tag):
    otag = obj.find(tag)
    if otag is not None:
        if len(otag):
            descr = etree.tostring(otag)
            return cleanHtml(descr)
        if otag.text is not None:
            return otag.text
    return ""

class RObject:
    def __init__(self, obj):
        self._obj = obj
        self.kind = obj.get("kind")

        if self.kind in ["class", "struct"]:
            self.signature = "{} {}".format(self.kind, getText(obj, "compoundname"))
            templargs = obj.find("templateparamlist")
            if templargs is not None and "<" not in self.signature:
                args = []
                for p in templargs:
                    # print(etree.tostring(p, pretty_print=True))
                    arg = "{} {}".format(getText(p, "type"), getText(p, "defname"))
                    defval = getText(p, "defval")
                    if len(defval):
                        arg += "={}".format(defval)
                    args.append(arg)
                self.signature = "{}< {} >".format(self.signature, ", ".join(args))
            self.signature += ";"

        elif self.kind in ["function", "typedef"]:
            self.signature = "{}{};".format(getText(obj, "definition"), getText(obj, "argsstring"))

        elif self.kind in ["enum"]:
            self.signature = "enum{} {};".format(" class" if obj.get("strong") == "yes" else "", getText(obj, "name"))

        elif self.kind in ["define"]:
            self.signature = "#define " + getText(obj, "name")
            params = obj.xpath(".//param/defname/text()")
            if len(params):
                self.signature += "({})".format(", ".join(params))

        elif self.kind in ["variable"]:
            self.signature = "{} {};".format(getText(obj, "definition"), getText(obj, "initializer"))

        else:
            raise Exception()

        self.signature = self.signature \
                            .replace("\n", "") \
                            .replace("&lt;", "<") \
                            .replace("&gt;", "<") \
                            .replace("&amp;", "&") \
                            .strip(" ")

    def render(self):
        return self.signature


def url_name(name):
    return name.replace(":", "-").replace(".", "-")

def ref_name(name):
    return name.replace(":", "_").replace(".", "_")

def node_name(name):
    return name.replace(":", ":\n")


def split_description(descr):
    description = []
    title = None
    for line in descr.splitlines():
        if title is None and line.startswith("#"):
            title = line.replace("#", "").strip()
            continue
        description.append(line)
    if len(description) == 1:
        title = description[0]
        description = []
    return title, "\n".join(description)

# -----------------------------------------------------------------------------
def init(module):
    module.name = "docs"

def prepare(module, options):
    return True

def build(env):
    env.outbasepath = "modm/docs"
    env.copy("doxyfile.cfg")

def post_build(env, buildlog):
    omodules = list(env.modules.values())
    omodules.sort(key=lambda m: m.fullname)
    modules = []

    env.log.info("Build dependency graph")
    for m in omodules:
        title, descr = split_description(m.description)
        mprops = {"name": m.fullname,
                  "title": title,
                  "description": descr,
                  "ref": url_name(m.fullname),
                  "dependencies": sorted([d.fullname for d in m.dependencies]),
                  "options": []}
        for o in m.options.values():
            title, descr = split_description(o.description)
            oprops = {"name": o.fullname,
                      "title": title,
                      "description": descr,
                      "default": str(o.value) if o.value is not None else None,
                      "possibles": o.values_hint()}
            mprops["options"].append(oprops)
        modules.append(mprops)

    for m in modules:
        m["dependents"] = []
        for d in modules:
            if m["name"] in d["dependencies"]:
                m["dependents"].append(d["name"])
        m["dependents"].sort()

        graph = gv.Digraph(name=m["name"],
                           format="svg",
                           graph_attr={"rankdir": "BT"},
                           node_attr={"style": "filled,solid", "shape": "box"})
        graph.node(ref_name(m["name"]), node_name(m["name"]), style="filled,bold")

        for mod in (m["dependencies"] + m["dependents"]):
            graph.node(ref_name(mod), node_name(mod), URL=("../" + url_name(mod)))
        for mod in m["dependencies"]:
            graph.edge(ref_name(m["name"]), ref_name(mod))
        for mod in m["dependents"]:
            graph.edge(ref_name(mod), ref_name(m["name"]))

        m["graph"] = graph.pipe().decode("utf-8")

    # Run doxygen
    env.log.info("Build doxygen")
    build_dir = Path(os.path.abspath(buildlog.get_operations_per_module("modm:docs")[0].filename_out)).parent
    subprocess.check_call("doxygen doxyfile.cfg", cwd=build_dir, shell=True)

    env.log.info("Parse doxygen")
    doxobjs = defaultdict(list)
    for compound in etree.parse(str(build_dir / "xml/index.xml")).xpath('//compound'):
        tree = etree.parse(str(build_dir / "xml/{}.xml".format(compound.get("refid"))))
        for obj in tree.xpath("//compounddef"):
            kind = obj.get("kind")
            if kind in ["dir", "group", "page"]: continue;

            name = obj.find("compoundname").text
            location = obj.find("location").get("file")

            if kind in ["struct", "class"]:
                doxobjs[location].append(obj)
                continue

            for member in obj.xpath("//memberdef"):
                kind = member.get("kind")
                name = member.find("name").text
                location = member.find("location").get("file")
                doxobjs[location].append(member)


    for m in modules:
        env.log.info("Render {}".format(m["name"]))
        outfiles = [os.path.abspath(op.filename_out) for op in buildlog.get_operations_per_module(m["name"])]
        outfiles = [o for o in outfiles if (o.endswith(".hpp") and not o.endswith("_impl.hpp"))]
        tmpobjects = OrderedDict({"class": [], "struct": [], "function": [], "enum": [], "variable": [], "typedef": [], "define": []})
        for of in outfiles:
            if of not in doxobjs:
                env.log.warning("Not documented: {}".format(os.path.relpath(of)))
                continue

            for obj in doxobjs[of]:
                try:
                    robj = RObject(obj)
                    # print(robj.render())
                    tmpobjects[robj.kind].append(robj.render())
                except:
                    traceback.print_exc()
                    print(etree.tostring(obj, pretty_print=True).decode('utf-8'))
                    return

        objects = OrderedDict()
        for kind, values in tmpobjects.items():
            if not len(values): continue;
            objects[kind] = sorted(values)

        env.substitutions = {"module": m, "objects": objects}
        env.template("module.md.in", "module/{}.md".format(url_name(m["name"])))


    # kinds:
    #   - author
    #   - class
    #   - define
    #   - dir
    #   - enum
    #   - file
    #   - friend
    #   - func
    #   - function
    #   - group
    #   - namespace
    #   - note
    #   - page
    #   - param
    #   - private-attrib
    #   - private-func
    #   - private-static-attrib
    #   - private-static-func
    #   - private-type
    #   - protected-attrib
    #   - protected-func
    #   - protected-static-attrib
    #   - protected-static-func
    #   - protected-type
    #   - public-attrib
    #   - public-func
    #   - public-static-attrib
    #   - public-static-func
    #   - public-type
    #   - return
    #   - retval
    #   - see
    #   - struct
    #   - templateparam
    #   - typedef
    #   - user-defined
    #   - var
    #   - variable
    #   - warning